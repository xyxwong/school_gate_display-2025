<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D æ¨¡å‹æ¼«éŠï¼ˆZIP -> GLB -> Three.jsï¼‰</title>

    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.155.0/build/three.module.js"
      }
    }
    </script>

    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Ctext y='14'%3EğŸ”·%3C/text%3E%3C/svg%3E">

    <style>
        html, body { height:100%; margin:0; background:#111; color:#fff; font-family:system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; }
        #container{position:fixed; inset:0; display:flex; align-items:stretch;}
        canvas{display:block}
        #loading { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; flex-direction:column; background: rgba(0,0,0,0.8); z-index:9999; gap:.75rem; }
        .spinner{ width:64px; height:64px; border-radius:50%; border:8px solid rgba(255,255,255,0.08); border-top-color:#00ffcc; animation:spin 1s linear infinite }
        @keyframes spin{ to{transform:rotate(360deg)} }
        #instructions{ position:fixed; left:50%; transform:translateX(-50%); bottom:24px; background:rgba(0,0,0,0.5); padding:8px 12px; border-radius:8px; font-size:14px; z-index:9000; }
        #enterButton{ background:#00ffcc; color:#001; border:none; padding:8px 12px; border-radius:6px; cursor:pointer; font-weight:600 }
        #hint { position:fixed; top:12px; left:12px; z-index:9000; background:rgba(0,0,0,0.45); padding:8px 10px; border-radius:6px; font-size:13px }
        #error{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.85); z-index:10000; padding:20px; }
        #error p{ color:#ff8080 }

        /* è™šæ‹Ÿæ‘‡æ†ï¼ˆé»˜è®¤éšè—ï¼Œä»…åœ¨ç§»åŠ¨ç«¯æ˜¾ç¤ºï¼‰ */
        #joystick { display: none; position: fixed; left: 60px; bottom: 80px; width: 120px; height: 120px; background: rgba(255,255,255,0.05); border-radius: 50%; touch-action: none; z-index: 9999; }
        #stick { position: absolute; left: 50%; top: 50%; width: 60px; height: 60px; background: rgba(0,255,204,0.6); border-radius: 50%; transform: translate(-50%,-50%); }
        #lookArea { display:none; position: fixed; right: 0; bottom: 0; width: 50%; height: 100%; z-index: 9998; touch-action: none; }
        /* åœ¨å°å±å¹•æ—¶æŠŠæ‘‡æ†å’Œ lookArea çš„å¤§å°/ä½ç½®å¯ä»¥å†è°ƒ */
    </style>
</head>
<body>

<div id="container"></div>

<div id="loading">
    <div class="spinner"></div>
    <p id="loadingText">æ¨¡å‹è¼‰å…¥ä¸­ï¼Œè«‹ç¨å€™â€¦</p>
</div>

<div id="hint">WASD ç§»å‹•ï¼Œæ»‘é¼ æ§åˆ¶è¦–è§’ï¼ŒShift åŠ é€Ÿï¼ŒEsc è§£é™¤æ¸¸æ¨™é–å®š</div>

<div id="instructions">
    <button id="enterButton">é»æˆ‘é–‹å§‹æ¼«éŠï¼ˆå•Ÿç”¨æ¸¸æ¨™é–å®šï¼‰</button>
</div>

<div id="error"><div><h3>è¼‰å…¥å¤±æ•—</h3><p id="errorMsg"></p></div></div>

<!-- æ–°å¢æ‰‹æ©Ÿ UI å…ƒç´ ï¼ˆå¿…é ˆå­˜åœ¨ä»¥é¿å… null.style éŒ¯èª¤ï¼‰ -->
<div id="joystick"><div id="stick"></div></div>
<div id="lookArea"></div>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'https://unpkg.com/three@0.155.0/examples/jsm/loaders/GLTFLoader.js';
import { DRACOLoader } from 'https://unpkg.com/three@0.155.0/examples/jsm/loaders/DRACOLoader.js';
import { PointerLockControls } from 'https://unpkg.com/three@0.155.0/examples/jsm/controls/PointerLockControls.js';
import { RGBELoader } from 'https://unpkg.com/three@0.155.0/examples/jsm/loaders/RGBELoader.js';


const container = document.getElementById('container');
const loading = document.getElementById('loading');
const loadingText = document.getElementById('loadingText');
const enterButton = document.getElementById('enterButton');
const instructions = document.getElementById('instructions');
const hint = document.getElementById('hint');
const errorBox = document.getElementById('error');
const errorMsg = document.getElementById('errorMsg');

const joystick = document.getElementById('joystick');
const stick = document.getElementById('stick');
const lookArea = document.getElementById('lookArea');

const zipPath = './model.zip';
const modelFileNameInZip = 'model.glb';

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222222);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
container.appendChild(renderer.domElement);

const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
hemi.position.set(0, 20, 0);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.8);
dir.position.set(5, 10, 7.5);
dir.castShadow = true;
scene.add(dir);

// ä¸å†è‡ªå‹•åŠ å…¥ groundï¼ˆä½ ä¹‹å‰è¨»è§£éï¼‰
// const ground = ...

const controls = new PointerLockControls(camera, renderer.domElement);

enterButton.addEventListener('click', ()=>{ controls.lock(); });

controls.addEventListener('lock', ()=>{ if(instructions) instructions.style.display = 'none'; if(hint) hint.style.display = 'block'; });
controls.addEventListener('unlock', ()=>{ if(instructions) instructions.style.display = 'block'; });

const moveState = { forward:false, backward:false, left:false, right:false, sprint:false };
const speed = 20;
const sprintMultiplier = 2.2;

// åˆ¤æ–­æ˜¯å¦ç§»åŠ¨è®¾å¤‡
const isMobile = /Android|iPhone|iPad|iPod|iOS/i.test(navigator.userAgent);

// mobile æ§åˆ¶å˜é‡
let joystickActive = false;
let joystickVector = {x:0, y:0};
let lookTouchActive = false;
let lastTouch = null;
let yaw = 0, pitch = 0;

// ä»…åœ¨å…ƒç´ å­˜åœ¨æ—¶è®¾ç½®æ˜¾ç¤º/äº‹ä»¶
if(isMobile){
  if(instructions) instructions.style.display = 'none';
  if(hint) hint.style.display = 'none';
  if(joystick) joystick.style.display = 'block';
  if(lookArea) lookArea.style.display = 'block';

  if(joystick){
    joystick.addEventListener('touchstart', e=>{
      e.preventDefault();
      joystickActive = true;
    }, { passive:false });
    joystick.addEventListener('touchend', e=>{
      e.preventDefault();
      joystickActive = false;
      joystickVector = {x:0,y:0};
      if(stick) { stick.style.left = "50%"; stick.style.top = "50%"; }
    }, { passive:false });
    joystick.addEventListener('touchmove', e=>{
      e.preventDefault();
      const rect = joystick.getBoundingClientRect();
      const touch = e.touches[0];
      const dx = touch.clientX - (rect.left + rect.width/2);
      const dy = touch.clientY - (rect.top + rect.height/2);
      const maxDist = rect.width/2 - 16;
      const dist = Math.min(Math.sqrt(dx*dx+dy*dy), maxDist);
      const angle = Math.atan2(dy, dx);
      joystickVector.x = Math.cos(angle) * (dist/(rect.width/2));
      joystickVector.y = Math.sin(angle) * (dist/(rect.height/2));
      if(stick){
        const lx = 50 + joystickVector.x * 40;
        const ty = 50 + joystickVector.y * 40;
        stick.style.left = `${lx}%`;
        stick.style.top  = `${ty}%`;
      }
    }, { passive:false });
  }

  if(lookArea){
    lookArea.addEventListener('touchstart', e=>{
      e.preventDefault();
      lookTouchActive = true;
      lastTouch = e.touches[0];
    }, { passive:false });
    lookArea.addEventListener('touchend', e=>{
      e.preventDefault();
      lookTouchActive = false;
      lastTouch = null;
    }, { passive:false });
    lookArea.addEventListener('touchmove', e=>{
      e.preventDefault();
      if(!lookTouchActive) return;
      const t = e.touches[0];
      if(!lastTouch) { lastTouch = t; return; }
      const dx = t.clientX - lastTouch.clientX;
      const dy = t.clientY - lastTouch.clientY;
      lastTouch = t;

      // è°ƒæ•´çµæ•åº¦ï¼ˆå¯å¾®è°ƒï¼‰
      yaw -= dx * 0.003;
      pitch -= dy * 0.003;
      pitch = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, pitch));
    }, { passive:false });
  }
} else {
  // æ¡Œé¢ï¼šéšè—æ‰‹æœº UIï¼ˆè‹¥å­˜åœ¨ï¼‰
  if(joystick) joystick.style.display = 'none';
  if(lookArea) lookArea.style.display = 'none';
}

function onKeyDown(e){
    switch(e.code){
        case 'ArrowUp': case 'KeyW': moveState.forward = true; break;
        case 'ArrowLeft': case 'KeyA': moveState.left = true; break;
        case 'ArrowDown': case 'KeyS': moveState.backward = true; break;
        case 'ArrowRight': case 'KeyD': moveState.right = true; break;
        case 'ShiftLeft': case 'ShiftRight': moveState.sprint = true; break;
    }
}
function onKeyUp(e){
    switch(e.code){
        case 'ArrowUp': case 'KeyW': moveState.forward = false; break;
        case 'ArrowLeft': case 'KeyA': moveState.left = false; break;
        case 'ArrowDown': case 'KeyS': moveState.backward = false; break;
        case 'ArrowRight': case 'KeyD': moveState.right = false; break;
        case 'ShiftLeft': case 'ShiftRight': moveState.sprint = false; break;
    }
}
window.addEventListener('keydown', onKeyDown);
window.addEventListener('keyup', onKeyUp);

window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// helper for JSZip (same robust approach you had)
async function ensureJSZipConstructor() {
  try {
    const mod = await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js');
    const JSZip = mod.default || mod.JSZip || mod;
    if (typeof JSZip === 'function') return JSZip;
  } catch (e) {
    console.warn('dynamic import JSZip failed, fallback to UMD:', e);
  }
  if (window.JSZip && typeof window.JSZip === 'function') return window.JSZip;
  await new Promise((resolve, reject) => {
    const url = 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js';
    const existing = Array.from(document.scripts).find(s => s.src && s.src.includes('jszip'));
    if (existing) {
      if (window.JSZip && typeof window.JSZip === 'function') return resolve();
      existing.addEventListener('load', () => resolve());
      existing.addEventListener('error', () => reject(new Error('Failed to load JSZip (existing script)')));
      return;
    }
    const s = document.createElement('script');
    s.src = url;
    s.onload = () => {
      if (window.JSZip && typeof window.JSZip === 'function') resolve();
      else reject(new Error('JSZip loaded but window.JSZip not found'));
    };
    s.onerror = () => reject(new Error('Failed to load JSZip UMD script'));
    document.head.appendChild(s);
  });
  if (window.JSZip && typeof window.JSZip === 'function') return window.JSZip;
  throw new Error('Unable to obtain JSZip constructor');
}

async function loadModelFromZip() {
  try {
    loadingText.textContent = 'æ­£åœ¨åŠ è¼‰ ZIP...';
    const resp = await fetch(zipPath);
    if (!resp.ok) throw new Error('ZIP ä¸‹è¼‰éŒ¯èª¤: ' + resp.status);
    const zipBlob = await resp.blob();

    loadingText.textContent = 'è§£å£“ç¸® ZIP...';
    const JSZip = await ensureJSZipConstructor();
    const jszip = new JSZip();
    const zip = await jszip.loadAsync(zipBlob);

    loadingText.textContent = 'æœå°‹æ¨¡å‹æª”æ¡ˆ...';
    console.log('ZIP files:', Object.keys(zip.files));

    let modelFile = zip.file(modelFileNameInZip);
    if(!modelFile){
        const glbEntry = Object.keys(zip.files).find(n=> n.toLowerCase().endsWith('.glb'));
        if(glbEntry) modelFile = zip.file(glbEntry);
    }
    if(!modelFile) throw new Error('ZIP å…§æ‰¾ä¸åˆ° .glb æª”æ¡ˆ');

    loadingText.textContent = 'è®€å–æ¨¡å‹è³‡æ–™...';
    const modelBlob = await modelFile.async('blob');
    const modelURL = URL.createObjectURL(modelBlob);

    const loader = new GLTFLoader();
    // Draco optional...
    loadingText.textContent = 'è¼‰å…¥ GLB...';
    loader.load(modelURL, gltf=>{
        const model = gltf.scene || gltf.scenes[0];
        model.traverse(child=>{ if(child.isMesh){ child.castShadow=true; child.receiveShadow=true; } });
        scene.add(model);

        // æŠŠæ¨¡å‹ä¸­å¿ƒç§»åˆ°åŸé»ï¼Œå†å‘ä¸ŠæŠ¬åŠé«˜åº¦ï¼Œä¿è­‰åº•é¢åœ¨ y=0
        const box = new THREE.Box3().setFromObject(model);
        const size = new THREE.Vector3(); box.getSize(size);
        const center = new THREE.Vector3(); box.getCenter(center);

        model.position.sub(center);
        model.position.y += size.y / 2;

        // åˆç†æ”¾ç½®ç›¸æ©Ÿï¼ˆç”¨æ¨¡å‹é«˜åº¦åšå‚è€ƒï¼‰
        const maxDim = Math.max(size.x, size.y, size.z);
        camera.position.set(0, 20, maxDim * 0.6 + 1);
        // For desktop pointer lock, position the controls' object too:
        controls.getObject().position.copy(camera.position);

        loading.style.display = 'none';
        URL.revokeObjectURL(modelURL);
        console.log('æ¨¡å‹è¼‰å…¥å®Œæˆ');
    }, xhr=>{
        if(xhr.total) {
            const p = Math.round((xhr.loaded / xhr.total) * 100);
            loadingText.textContent = `è¼‰å…¥ GLB... ${p}%`;
        }
    }, err=>{
        throw err;
    });
    const rgbeLoader = new RGBELoader();
    rgbeLoader.setPath('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/2k/');
    rgbeLoader.load('kloofendal_48d_partly_cloudy_puresky_2k.hdr', (texture)=>{
        texture.mapping = THREE.EquirectangularReflectionMapping;
        scene.environment = texture;   // ç¯å¢ƒå…‰ç…§ï¼ˆå½±å“ PBR æè´¨ï¼‰
        scene.background = texture;    // èƒŒæ™¯è®¾ç½®ä¸º HDRï¼ˆä¹Ÿå¯æ”¹å›é¢œè‰²ï¼‰
    });


  }catch(err){
    console.error(err);
    if(errorMsg) errorMsg.textContent = err.message || String(err);
    if(errorBox) errorBox.style.display = 'flex';
    if(loading) loading.style.display = 'none';
  }
}

/* å‹•ç•«èˆ‡ç§»å‹• */
const clock = new THREE.Clock();
function animate(){
    requestAnimationFrame(animate);
    const dt = clock.getDelta();

    if (isMobile) {
    // ç§»åŠ¨ç«¯ï¼šæ‘‡æ†æ§åˆ¶ç§»åŠ¨ï¼Œè§¦æ§æ§åˆ¶è§†è§’
    const moveSpeed = speed * (moveState.sprint ? sprintMultiplier : 1);

    // æ ¹æ® yaw/pitch æ›´æ–°ç›¸æœºæ–¹å‘ï¼ˆæ³¨æ„ï¼šä¸ä¼šä½¿ç”¨ pointer lockï¼‰
    camera.rotation.order = 'YXZ';
    camera.rotation.y = yaw;
    camera.rotation.x = pitch;

    // æŠŠæ‘‡æ†è¾“å…¥è½¬æ¢ä¸ºå‰/å³åˆ†é‡ï¼ˆæ³¨æ„ Y è½´å±å¹•å‘ä¸‹ä¸ºæ­£ï¼Œæ‰€ä»¥å‘ä¸Šè¦å–è´Ÿï¼‰
    const forwardInput = -joystickVector.y; // æ¨ä¸Š => forwardInput æ­£
    const strafeInput  = joystickVector.x;  // æ¨å³ => strafeInput æ­£

    // è®¡ç®—æ‘„åƒæœºæœå‰çš„å‘é‡ï¼ˆåŸºäº yawï¼‰ï¼Œè¿™é‡Œä½¿ç”¨æ‘„åƒæœºå®é™…çš„ forwardï¼ˆæŒ‡å‘ -Z çš„æ—‹è½¬ç»“æœï¼‰
    // forwardVec = rotationY(yaw) * (0,0,-1)
    const forwardVec = new THREE.Vector3(
        -Math.sin(yaw),
        0,
        -Math.cos(yaw)
    ).normalize();

    // å³å‘é‡ = forward Ã— upï¼ˆè¿™ä¼šå¾—åˆ°é¢å‘å³æ–¹çš„å‘é‡ï¼‰
    const up = new THREE.Vector3(0, 1, 0);
    const rightVec = new THREE.Vector3().crossVectors(forwardVec, up).normalize();

    // ç»„åˆç§»åŠ¨
    const move = new THREE.Vector3();
    move.addScaledVector(forwardVec, forwardInput * moveSpeed * dt);
    move.addScaledVector(rightVec,  strafeInput  * moveSpeed * dt);

    camera.position.add(move);
}
 else {
        // æ¡Œé¢ç«¯ï¼šåŸæœ‰ pointer lock æ§åˆ¶
        if(controls.isLocked){
            const forward = (moveState.forward?1:0) - (moveState.backward?1:0);
            const strafe = (moveState.right?1:0) - (moveState.left?1:0);
            const moveSpeed = speed * (moveState.sprint? sprintMultiplier : 1);

            const dir = new THREE.Vector3();
            controls.getDirection(dir);
            dir.y = 0; dir.normalize();
            const right = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0,1,0)).normalize();

            const move = new THREE.Vector3();
            move.addScaledVector(dir, forward * moveSpeed * dt);
            move.addScaledVector(right, strafe * moveSpeed * dt);
            controls.getObject().position.add(move);
        }
    }

    renderer.render(scene, camera);
}

loadModelFromZip().then(()=>{ animate(); });

</script>

</body>
</html>
